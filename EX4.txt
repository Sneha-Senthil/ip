import cv2
import os

# Load the video
video_path = 'video.mp4'  # replace with your video file
cap = cv2.VideoCapture(video_path)

# Directory to save frames
output_dir = 'frames'
os.makedirs(output_dir, exist_ok=True)

frame_count = 0

while True:
    ret, frame = cap.read()
    if not ret:
        break
    
    # Save each frame as an image
    frame_filename = os.path.join(output_dir, f'frame_{frame_count:04d}.jpg')
    cv2.imwrite(frame_filename, frame)
    
    frame_count += 1

cap.release()
print(f"Total frames extracted: {frame_count}")



horse and human
pip install tensorflow tensorflow-datasets matplotlib

import tensorflow as tf
import tensorflow_datasets as tfds
import matplotlib.pyplot as plt
import numpy as np

# a. Load the dataset
(ds_train, ds_test), ds_info = tfds.load(
    'horses_or_humans',
    split=['train', 'test'],
    as_supervised=True,
    with_info=True
)

# b. View the number of training and testing images
print("Training images:", ds_info.splits['train'].num_examples)
print("Testing images:", ds_info.splits['test'].num_examples)

# c. Plot some images
plt.figure(figsize=(10,5))
for i, (img, label) in enumerate(ds_train.take(6)):
    plt.subplot(2,3,i+1)
    plt.imshow(img)
    plt.title("Horse" if label==0 else "Human")
    plt.axis('off')
plt.show()

# d. Normalizing the training data
def normalize_img(image, label):
    image = tf.cast(image, tf.float32) / 255.0
    return image, label

ds_train = ds_train.map(normalize_img).batch(32).prefetch(1)
ds_test = ds_test.map(normalize_img).batch(32).prefetch(1)

# e. Build a simple ResNet-based CNN
base_model = tf.keras.applications.ResNet50(
    weights=None, include_top=False, input_shape=(300,300,3), pooling='avg'
)
model = tf.keras.Sequential([
    base_model,
    tf.keras.layers.Dense(1, activation='sigmoid')
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# f. Train and show accuracy
history = model.fit(ds_train, epochs=5, validation_data=ds_test)

print("Training accuracy:", history.history['accuracy'][-1])
print("Testing accuracy:", history.history['val_accuracy'][-1])

or

import tensorflow as tf
import tensorflow_datasets as tfds
import matplotlib.pyplot as plt

# a. Load the dataset
(ds_train, ds_test), ds_info = tfds.load(
    'horses_or_humans',
    split=['train', 'test'],
    as_supervised=True,
    with_info=True
)

# b. Show dataset size
print("Training images:", ds_info.splits['train'].num_examples)
print("Testing images:", ds_info.splits['test'].num_examples)

# c. Plot sample images
plt.figure(figsize=(10,5))
for i, (img, label) in enumerate(ds_train.take(6)):
    plt.subplot(2,3,i+1)
    plt.imshow(img)
    plt.title("Horse" if label==0 else "Human")
    plt.axis('off')
plt.show()

# d. Normalize + resize (smaller for speed)
def normalize_img(image, label):
    image = tf.cast(image, tf.float32) / 255.0
    image = tf.image.resize(image, (160, 160))  # smaller input
    return image, label

# Use fewer images to train faster
ds_train = ds_train.take(400).map(normalize_img).batch(16).prefetch(tf.data.AUTOTUNE)
ds_test = ds_test.take(100).map(normalize_img).batch(16).prefetch(tf.data.AUTOTUNE)

# e. Use a lightweight model (MobileNetV2 instead of ResNet)
base_model = tf.keras.applications.MobileNetV2(
    weights=None, include_top=False, input_shape=(160,160,3), pooling='avg'
)

model = tf.keras.Sequential([
    base_model,
    tf.keras.layers.Dense(1, activation='sigmoid')
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# f. Train for fewer epochs
history = model.fit(ds_train, epochs=3, validation_data=ds_test)

print("\nTraining accuracy:", history.history['accuracy'][-1])
print("Testing accuracy:", history.history['val_accuracy'][-1])
